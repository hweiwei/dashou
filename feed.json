{
    "version": "https://jsonfeed.org/version/1",
    "title": "大手游戏",
    "description": "",
    "home_page_url": "https://hweiwei.github.io/dashou",
    "feed_url": "https://hweiwei.github.io/dashou/feed.json",
    "user_comment": "",
    "author": {
        "name": "黄伟伟"
    },
    "items": [
        {
            "id": "https://hweiwei.github.io/dashou/dong-tai-gui-hua-xian-ding-tiao-jian-qiu-zui-you-jie-2.html",
            "url": "https://hweiwei.github.io/dashou/dong-tai-gui-hua-xian-ding-tiao-jian-qiu-zui-you-jie-2.html",
            "title": "动态规划-限定条件求最优解",
            "summary": "原文发布于微信公众号https://mp.weixin.qq.com/s?__biz=MzI4MDA3MTcyMA==&amp;mid=2247483680&amp;idx=1&amp;sn=49c0d6934538cac1fe79d0430459b8d1&amp;chksm=ebbf5a67dcc8d371ca1f64da1dc7b23637cbbf1fd58e521e2cd6f4d37b4dcc79277343c81375&amp;token=1598275063&amp;lang=zh_CN#rd 游戏中经常会用到一些buff道具，最常见的比如建造建筑时使用的时间缩短道具，行军加速道具包，血量回复包等。在几种道具中选择最合适的道具包达到目标效果。许多游戏中的解决方法是使用贪心算法，这种只是一般可行解，并不被玩家接受。用动态规划算法可以构造出最优解。 动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划 我们先来构造一般意义上的最优解 假设当前我们在建造一个建筑，建筑需花费n小时的时间，玩家拥有3种道具a、b、c,分别能使建筑时间缩短1、2、3小时，我们来看看每个阶段的最优解情况 我们来解释下表格所表达的意思，一般的我们认为在所有道具都参与的情况下的解决方案为最优解，并且优先使用时效长的道具 当目标为缩短1小时的时候的最有解，结果为使用 1个道具a。同理，目标为2时使用一个b,目标为3时使用一个道具3。观察3中的第二列解 意思为当目标为缩短3个小时时，在拥有道具a和b情况下的最有解。 至此，大家应该明白表格所表达的意思了吧。 现在，我们对道具数量做出限定，假定在b、c只拥有一个的情况下，求6小时的最优解。我们继续构造最优解表格 表格理解应该是没有难度了，现在我们来分析下如何用代码实现。。。中间省略无数，直接贴代码。新建一个html打开在控制台查看结果即可。 &lt;html&gt; &lt;body&gt; &lt;script&gt; const MAX = 1000000 /**数组对象深拷贝*/&hellip;",
            "content_html": "<p>原文发布于微信公众号<a href=\"https://hweiwei.github.io/dashou/dong-tai-gui-hua-xian-ding-tiao-jian-qiu-zui-you-jie-2.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://mp.weixin.qq.com/s?__biz=MzI4MDA3MTcyMA==&amp;mid=2247483680&amp;idx=1&amp;sn=49c0d6934538cac1fe79d0430459b8d1&amp;chksm=ebbf5a67dcc8d371ca1f64da1dc7b23637cbbf1fd58e521e2cd6f4d37b4dcc79277343c81375&amp;token=1598275063&amp;lang=zh_CN#rd</a></p>\n<p>游戏中经常会用到一些buff道具，最常见的比如建造建筑时使用的时间缩短道具，行军加速道具包，血量回复包等。在几种道具中选择最合适的道具包达到目标效果。许多游戏中的解决方法是使用贪心算法，这种只是一般可行解，并不被玩家接受。用动态规划算法可以构造出最优解。</p>\n<p>动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划</p>\n<p>我们先来构造一般意义上的最优解</p>\n<p>假设当前我们在建造一个建筑，建筑需花费n小时的时间，玩家拥有3种道具a、b、c,分别能使建筑时间缩短1、2、3小时，我们来看看每个阶段的最优解情况</p>\n<table style=\"border-collapse: collapse; width: 115.1%; height: 325px;\" border=\"1\">\n<tbody>\n<tr>\n<td style=\"width: 16.3569%;\">道具\\目标</td>\n<td style=\"width: 16.6047%;\">1</td>\n<td style=\"width: 16.7286%;\">2</td>\n<td style=\"width: 16.8524%;\">3</td>\n<td style=\"width: 16.6049%;\">4</td>\n<td style=\"width: 16.8525%;\">5</td>\n</tr>\n<tr>\n<td style=\"width: 16.3569%;\">道具a（缩短1小时）</td>\n<td style=\"width: 16.6047%;\">a*1</td>\n<td style=\"width: 16.7286%;\">a*2</td>\n<td style=\"width: 16.8524%;\">a*3</td>\n<td style=\"width: 16.6049%;\">a*4</td>\n<td style=\"width: 16.8525%;\">a*5</td>\n</tr>\n<tr>\n<td style=\"width: 16.3569%;\">道具b（缩短2小时）</td>\n<td style=\"width: 16.6047%;\">a*1</td>\n<td style=\"width: 16.7286%;\">b * 1</td>\n<td style=\"width: 16.8524%;\">b * 1+ a * 1</td>\n<td style=\"width: 16.6049%;\">b*2</td>\n<td style=\"width: 16.8525%;\">b * 2 + a * 1</td>\n</tr>\n<tr>\n<td style=\"width: 16.3569%;\">道具c（缩短3小时）</td>\n<td style=\"width: 16.6047%;\">a*1</td>\n<td style=\"width: 16.7286%;\">b*1</td>\n<td style=\"width: 16.8524%;\">c*1</td>\n<td style=\"width: 16.6049%;\">c * 1 + a * 1</td>\n<td style=\"width: 16.8525%;\">c *1 + b * 1</td>\n</tr>\n</tbody>\n</table>\n<p>我们来解释下表格所表达的意思，<strong>一般的我们认为在所有道具都参与的情况下的解决方案为最优解</strong>，并且优先使用时效长的道具</p>\n<p><img loading=\"lazy\" src=\"https://mmbiz.qpic.cn/mmbiz_png/sXtOkUEVsctQib5DXgn1xPUibtBEibY0I63k7ic5HSX4RBhLS43icuicebfib4EtLpmCAxcjEqqm2S3ib4HHh7PNFVDY9g/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" data-is-external-image=\"true\"  alt=\"图片\"></p>\n<p>当目标为缩短1小时的时候的最有解，结果为使用 1个道具a。同理，目标为2时使用一个b,目标为3时使用一个道具3。观察3中的第二列解</p>\n<p><img loading=\"lazy\" src=\"https://mmbiz.qpic.cn/mmbiz_png/sXtOkUEVsctQib5DXgn1xPUibtBEibY0I63hRHPib1t9zcHKsM0IUJZiarf0ud1cCvnJTYiaQfsLWZ8SHVELh4ficSK1w/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" data-is-external-image=\"true\"  alt=\"图片\"></p>\n<p>意思为当目标为缩短3个小时时，在拥有道具a和b情况下的最有解。</p>\n<p>至此，大家应该明白表格所表达的意思了吧。</p>\n<p>现在，我们对道具数量做出限定，假定在b、c只拥有一个的情况下，求6小时的最优解。我们继续构造最优解表格</p>\n<table style=\"border-collapse: collapse; width: 114.815%; height: 434px;\" border=\"1\">\n<tbody>\n<tr>\n<td style=\"width: 15.4762%;\">道具\\目标</td>\n<td style=\"width: 9.04762%;\">1</td>\n<td style=\"width: 9.40476%;\">2</td>\n<td style=\"width: 11.6667%;\">3</td>\n<td style=\"width: 28.3333%;\">4</td>\n<td style=\"width: 11.9048%;\">5</td>\n<td style=\"width: 14.1667%;\">6</td>\n</tr>\n<tr>\n<td style=\"width: 15.4762%;\">道具a（缩短1小时）</td>\n<td style=\"width: 9.04762%;\">a*1</td>\n<td style=\"width: 9.40476%;\">a*2</td>\n<td style=\"width: 11.6667%;\">a*3</td>\n<td style=\"width: 28.3333%;\">a*4</td>\n<td style=\"width: 11.9048%;\">a*5</td>\n<td style=\"width: 14.1667%;\">a*6</td>\n</tr>\n<tr>\n<td style=\"width: 15.4762%;\">道具b（缩短2小时）*1</td>\n<td style=\"width: 9.04762%;\">a*1</td>\n<td style=\"width: 9.40476%;\">b * 1</td>\n<td style=\"width: 11.6667%;\">b * 1+ a * 1</td>\n<td style=\"width: 28.3333%;\">b * 1+a * 2(原则上b*2是最优解，b数量超出,需要找出b的替代解)</td>\n<td style=\"width: 11.9048%;\">b * 1 + a * 3</td>\n<td style=\"width: 14.1667%;\">b*1 + a * 4</td>\n</tr>\n<tr>\n<td style=\"width: 15.4762%;\">道具c（缩短3小时）*1</td>\n<td style=\"width: 9.04762%;\">a*1</td>\n<td style=\"width: 9.40476%;\">b*1</td>\n<td style=\"width: 11.6667%;\">c*1</td>\n<td style=\"width: 28.3333%;\">c * 1 + a * 1</td>\n<td style=\"width: 11.9048%;\">c *1 + b * 1</td>\n<td style=\"width: 14.1667%;\">c *1 + b * 1 + a * 1</td>\n</tr>\n</tbody>\n</table>\n<p>表格理解应该是没有难度了，现在我们来分析下如何用代码实现。。。中间省略无数，直接贴代码。新建一个html打开在控制台查看结果即可。</p>\n<p><code>&lt;html&gt;</code></p>\n<p><code>    &lt;body&gt;</code></p>\n<p><code>       &lt;script&gt;</code></p>\n<p><code>           const MAX = 1000000</code></p>\n<p><code>           /**数组对象深拷贝*/</code></p>\n<p><code>           function copy(list) {</code></p>\n<p><code>               let obj</code></p>\n<p><code>             let isArr = Array.isArray(list)</code></p>\n<p><code>              let isObj = list != null &amp;&amp; list instanceof Object</code></p>\n<p><code>            if (isArr) {</code></p>\n<p><code>                   obj = []</code></p>\n<p><code>                  for (let i = 0; i &lt; list.length; i++) {</code></p>\n<p><code>                        obj[i] = copy(list[i])</code></p>\n<p><code>                  }</code></p>\n<p><code>               } else if (isObj) {</code></p>\n<p><code>                  obj = {}</code></p>\n<p><code>                  for (let i in list) {</code></p>\n<p><code>                       obj[i] = copy(list[i])</code></p>\n<p><code>                  }</code></p>\n<p><code>               } else {</code></p>\n<p><code>                    obj = list</code></p>\n<p><code>              }</code></p>\n<p><code>               return obj</code></p>\n<p><code>         }</code></p>\n<p><code>           //删除无效项</code></p>\n<p><code>            function removeNoCount(list) {</code></p>\n<p><code>               let len = list.length</code></p>\n<p><code>             while (len--) {</code></p>\n<p><code>                   if (list[len].count == 0) {</code></p>\n<p><code>                       list.splice(len, 1)</code></p>\n<p><code>                    }</code></p>\n<p><code>             }</code></p>\n<p><code>           }</code></p>\n<p> </p>\n<p><code>          function getBest(list, effect) {</code></p>\n<p><code>                let keys = copy(list)</code></p>\n<p><code>               removeNoCount(keys)</code></p>\n<p><code>                let kinds = keys.length</code></p>\n<p><code>             let allEffect = 0</code></p>\n<p><code>              for (let i of list) {</code></p>\n<p><code>                    allEffect += i.value * i.count</code></p>\n<p><code>             }</code></p>\n<p><code>               //所有效果总和不比需求来得大，不必计算</code></p>\n<p><code>              if (allEffect &lt;= effect) {</code></p>\n<p><code>                   return { value: MAX }</code></p>\n<p><code>              }</code></p>\n<p><code>                let values = []</code></p>\n<p><code>             /**构建一个二位数组表，value为当前的结果值，id为存放道具id组合*/</code></p>\n<p><code>                for (let i = 0; i &lt;= kinds; i++) {</code></p>\n<p><code>                   values[i] = []</code></p>\n<p><code>                 for (let j = 0; j &lt;= effect; j++) {</code></p>\n<p><code>                      values[i][j] = {}</code></p>\n<p><code>                       values[i][j]['value'] = MAX</code></p>\n<p><code>                       values[i][j]['id'] = {}</code></p>\n<p><code>                       for (let key of list) {</code></p>\n<p><code>                           values[i][j]['id'][key.id] = 0</code></p>\n<p><code>                       }</code></p>\n<p><code>                    }</code></p>\n<p><code>                   values[i][0]['value'] = 0</code></p>\n<p><code>                }</code></p>\n<p><code>                for (let i = 0; i &lt;= effect; i++) {</code></p>\n<div>                    values[0][i]['value'] = MAX\n<p><code>               }</code></p>\n<p><code>               for (let eff = 1; eff &lt;= effect; eff++) {</code></p>\n<p><code>                   for (let key = 1; key &lt;= kinds; key++) {</code></p>\n<p><code>                       //如果左侧没有最优解，则当前项不可能有最优解</code></p>\n<p><code>                     if (values[key][eff - 1].value == MAX) {</code></p>\n<p><code>                          values[key][eff].value = MAX</code></p>\n<p><code>                           continue</code></p>\n<p><code>                      }</code></p>\n<p><code>                      let value = keys[key - 1].value</code></p>\n<p><code>                      let id = keys[key - 1].id</code></p>\n<p><code>                        let upItem = values[key - 1][eff]</code></p>\n<p><code>                      let nowItem = values[key][eff]</code></p>\n<p><code>                        //如果目标值小于当前的道具效果值，将上一个目标结果与当前的效果值做比较，取小</code></p>\n<p><code>                        //参考 需要目标值为1时的推导</code></p>\n<p><code>                        if (eff &lt; value) {</code></p>\n<p><code>                           let value1 = upItem.value //目标上一个结果值</code></p>\n<p><code>                          if (value1 &lt; value) {</code></p>\n<p><code>                               nowItem.value = value1</code></p>\n<p><code>                              nowItem.id = copy(upItem.id)</code></p>\n<p><code>                            } else {</code></p>\n<p><code>                               nowItem.value = value</code></p>\n<p><code>                               nowItem.id[id]++</code></p>\n<p><code>                            }</code></p>\n<p><code>                           continue</code></p>\n<p><code>                       }</code></p>\n<p><code>                       let leftItem = values[key][eff - value]</code></p>\n<p><code>                        let canUsed = leftItem.id[id] &lt; keys[key - 1].count</code></p>\n<br>\n<p><code>                        //当前项不可用</code></p>\n<p><code>                       if (!canUsed) {</code></p>\n<p><code>                           for (let k = key - 1; k &gt; 0; k--) {</code></p>\n<p><code>                               leftItem = copy(values[k][eff - value])</code></p>\n<p><code>                                let canUsed = leftItem.id[id] &lt; keys[key - 1].count</code></p>\n<p><code>                                break</code></p>\n<p><code>                           }</code></p>\n<p><code>                       }</code></p>\n<p><code>                       if (leftItem.value == MAX) {</code></p>\n<p><code>                         nowItem.value = MAX</code></p>\n<p><code>                            continue</code></p>\n<p><code>                        }</code></p>\n<p><code>                       let value1 = upItem.value</code></p>\n<p><code>                      let value2 = leftItem.value + value</code></p>\n<p><code>                       if (value1 &lt; value2) {</code></p>\n<p><code>                           nowItem.value = value1</code></p>\n<p><code>                           nowItem.id = copy(upItem.id)</code></p>\n<p><code>                       } else {</code></p>\n<p><code>                          nowItem.value = value2</code></p>\n<p><code>                          nowItem.id = copy(leftItem.id)</code></p>\n<p><code>                          nowItem.id[id]++</code></p>\n<p><code>                       }</code></p>\n<p><code>                    }</code></p>\n<p><code>              }</code></p>\n<p><code>              console.log(values[kinds][effect])</code></p>\n<p><code>                return values[kinds][effect]</code></p>\n<p><code>          }</code></p>\n<p><code>           let list = [</code></p>\n<p><code>               { id: '时间道具a', value: 3, count: 6 },</code></p>\n<p><code>                { id: '时间道具b', value: 5, count: 2 },</code></p>\n<p><code>            { id: '时间道具c', value: 7, count: 2 },</code></p>\n<p><code>              { id: '时间道具d', value: 99, count: 5 },</code></p>\n<p><code>            ]</code></p>\n<p><code>         let eff = 517</code></p>\n<p><code>            getBest(list, eff)</code></p>\n<p><code>       &lt;/script&gt;</code></p>\n<p><code>    &lt;/body&gt;</code></p>\n<p><code>&lt;/html&gt;</code></p>\n<p><code></code></p>\n</div>",
            "author": {
                "name": "黄伟伟"
            },
            "tags": [
            ],
            "date_published": "2023-08-01T14:46:50+08:00",
            "date_modified": "2023-08-01T15:10:11+08:00"
        },
        {
            "id": "https://hweiwei.github.io/dashou/cocosre-geng-dong-tai-ban-ben-di-zhi-yan-jiu-2.html",
            "url": "https://hweiwei.github.io/dashou/cocosre-geng-dong-tai-ban-ben-di-zhi-yan-jiu-2.html",
            "title": "cocos热更动态版本地址研究",
            "summary": "cocos creator 2.x 版本中，关于热更的远程地址，版本等信息来源于工程中写入的project.manifest ，没有提供外部修改接口。如果想更自由的管理版本、热更地址配置，势必要修改源码。但是修改源码对于cocos 引擎版本升级不够友好。经过研究jsb 相关内容，这边提供一个在不修改源码的情况下达到自由控制版本信息的方法。 获取本地热更文件project.manifest 获得内容data 并解析 let asset = JSON.parse(data._nativeAsset); 修改asset 内容 asset.packageUrl = this.serverUrl +&hellip;",
            "content_html": "<p>cocos creator 2.x 版本中，关于热更的远程地址，版本等信息来源于工程中写入的project.manifest ，没有提供外部修改接口。如果想更自由的管理版本、热更地址配置，势必要修改源码。但是修改源码对于cocos 引擎版本升级不够友好。经过研究jsb 相关内容，这边提供一个在不修改源码的情况下达到自由控制版本信息的方法。</p>\n<ol>\n<li><p>获取本地热更文件project.manifest 获得内容data 并解析 </p>\n<pre><code>let asset = JSON.parse(data._nativeAsset);  \n</code></pre>\n</li>\n<li><p>修改asset 内容</p>\n</li>\n</ol>\n<pre><code>asset.packageUrl = this.serverUrl + HOT_PACKAGE + version;\nasset.remoteManifestUrl = this.serverUrl + HOT_PACKAGE + version + manifest + &quot;/project.manifest&quot;;\nasset.remoteVersionUrl = this.serverUrl + HOT_PACKAGE + version + manifest + &quot;/version.manifest&quot;;\n</code></pre>\n<ol start=\"3\">\n<li>判定是否存在存储的热更文件 jsb.fileUtils.isFileExist(this.storagePath + “/project.manifest”)，如果存在更新该文件</li>\n</ol>\n<pre><code class=\"language-if\">    let str = jsb.fileUtils.getStringFromFile(this.storagePath + &quot;/project.manifest&quot;);\n    let json = JSON.parse(str);\n    json.packageUrl = asset.packageUrl;\n    json.remoteManifestUrl = asset.remoteManifestUrl;\n    json.remoteVersionUrl = asset.remoteVersionUrl;\n    jsb.fileUtils.writeStringToFile(JSON.stringify(json), this.storagePath + &quot;/project.manifest&quot;);\n}\n</code></pre>\n<p>这一步的目的是因为源码中，会优先使用存贮的热更文件</p>\n<pre><code>// Compare with cached manifest to determine which one to use\nif (cachedManifest)\n{\n    bool localNewer = _localManifest-&gt;versionGreater(cachedManifest, _versionCompareHandle);\n    if (localNewer)\n    {\n        // Recreate storage, to empty the content\n        _fileUtils-&gt;removeDirectory(_storagePath);\n        _fileUtils-&gt;createDirectory(_storagePath);\n        CC_SAFE_RELEASE(cachedManifest);\n    }\n    else\n    {\n        CC_SAFE_RELEASE(_localManifest);\n        _localManifest = cachedManifest;\n    }\n}\n</code></pre>\n<ol start=\"4\">\n<li>构造新的manifest 对象</li>\n</ol>\n<pre><code>let mani = new jsb.Manifest(JSON.stringify(asset), this.storagePath);\n</code></pre>\n<p>5.热更管理器加载该配置对象即可。</p>\n<pre><code>this._assetManager.loadLocalManifest(mani, this.storagePath);\n</code></pre>\n<p><em><strong>注意</strong></em>：在构造热更管理器时不要传入原始的manifest 文件，否则loadLocalManifest方法将失效</p>\n<pre><code>this._assetManager = new jsb.AssetsManager(&quot;&quot;, this.storagePath, this.versionCompareHandle);\n</code></pre>\n",
            "author": {
                "name": "黄伟伟"
            },
            "tags": [
            ],
            "date_published": "2023-08-01T09:48:32+08:00",
            "date_modified": "2023-08-01T13:33:46+08:00"
        },
        {
            "id": "https://hweiwei.github.io/dashou/shader-zhi-shan-dian-te-xiao.html",
            "url": "https://hweiwei.github.io/dashou/shader-zhi-shan-dian-te-xiao.html",
            "title": "shader 之闪电特效",
            "content_html": "\n  <p>\n    \n  </p>",
            "author": {
                "name": "黄伟伟"
            },
            "tags": [
            ],
            "date_published": "2022-10-08T15:20:39+08:00",
            "date_modified": "2022-10-08T15:20:39+08:00"
        },
        {
            "id": "https://hweiwei.github.io/dashou/jie-jue-24x-ios-zhen-ji-shan-tui-wen-ti.html",
            "url": "https://hweiwei.github.io/dashou/jie-jue-24x-ios-zhen-ji-shan-tui-wen-ti.html",
            "title": "解决2.4.x ios 真机闪退问题",
            "summary": "由于 jit 不支持ios ，引擎错误开启支持导致。修改 \\cocos2d-x\\cocos\\scripting\\js-bindings\\jswrapper\\v8\\ScriptEngine.cpp 该路径下方法jitSupported bool jitSupported() { #if CC_IOS_FORCE_DISABLE_JIT return false; #elif TARGET_CPU_X86 || TARGET_CPU_X86_64 return true; #else&hellip;",
            "content_html": "<p>由于 jit 不支持ios ，引擎错误开启支持导致。修改 \\cocos2d-x\\cocos\\scripting\\js-bindings\\jswrapper\\v8\\ScriptEngine.cpp 该路径下方法jitSupported</p>\n<pre><code>\nbool jitSupported() {\n            #if CC_IOS_FORCE_DISABLE_JIT\n            return false;\n            #elif TARGET_CPU_X86 || TARGET_CPU_X86_64\n            return true;\n            #else\n            \n            //2022.7.1 暂时移除其他版本jit支持，解决真机闪退问题\n//            // Check for arm64e.\n//            cpu_type_t cpuType = 0;\n//            size_t cpuTypeSize = sizeof(cpu_type_t);\n//            if (::sysctlbyname(&quot;hw.cputype&quot;, &amp;cpuType, &amp;cpuTypeSize, nullptr, 0) &lt; 0) {\n//                SE_LOGD(&quot;Could not execute sysctl() to get CPU type: %s&quot;, strerror(errno));\n//            }\n//\n//            cpu_subtype_t cpuSubType = 0;\n//            if (::sysctlbyname(&quot;hw.cpusubtype&quot;, &amp;cpuSubType, &amp;cpuTypeSize, nullptr, 0) &lt; 0) {\n//                SE_LOGD(&quot;Could not execute sysctl() to get CPU subtype: %s&quot;, strerror(errno));\n//            }\n//\n//            // Tracing is necessary unless the device is arm64e (A12 chip or higher).\n//            if (cpuType != CPU_TYPE_ARM64 || cpuSubType != CPU_SUBTYPE_ARM64E) {\n//                return false;\n//            }\n//\n//            // Check for iOS 14.2 and higher.\n//            size_t osVersionSize;\n//            ::sysctlbyname(&quot;kern.osversion&quot;, NULL, &amp;osVersionSize, NULL, 0);\n//            char osversionBuffer[osVersionSize];\n//\n//            if (::sysctlbyname(&quot;kern.osversion&quot;, osversionBuffer, &amp;osVersionSize, NULL, 0) &lt; 0) {\n//                SE_LOGD(&quot;Could not execute sysctl() to get current OS version: %s&quot;, strerror(errno));\n//                return false;\n//            }\n//\n//            int majorVersion = 0;\n//            char minorLetter = &#39;Z&#39;;\n//\n//            for (size_t index = 0; index &lt; osVersionSize; index++) {\n//                char version_char = osversionBuffer[index];\n//                // Find the minor version build letter.\n//                if (isalpha(version_char)) {\n//                    majorVersion = atoi((const char*)osversionBuffer);\n//                    minorLetter = toupper(version_char);\n//                    break;\n//                }\n//            }\n//            // 18B92 is iOS 14.2 beta release candidate where tracing became unnecessary.\n//            return majorVersion &gt; 18 || (majorVersion == 18 &amp;&amp; minorLetter &gt;= &#39;B&#39;);\n            return false;\n            #endif //TARGET_CPU_X86 || TARGET_CPU_X86_64\n        }\n                \n</code></pre>\n",
            "author": {
                "name": "黄伟伟"
            },
            "tags": [
            ],
            "date_published": "2022-09-23T10:43:08+08:00",
            "date_modified": "2022-09-23T10:49:36+08:00"
        },
        {
            "id": "https://hweiwei.github.io/dashou/guan-yu-cocos-creator-duo-bundle-re-geng-yan-jiu.html",
            "url": "https://hweiwei.github.io/dashou/guan-yu-cocos-creator-duo-bundle-re-geng-yan-jiu.html",
            "title": "ios 覆盖安装问题研究",
            "summary": "在实现cocos热更方案过程中，一切都很顺利。所有工作完成之后，发现ios 在覆盖安装之后，如果没有清理缓存，即使安装的版本是旧的也不会进行热更。这种情况，比较好理解，版本文件还在，所以比对版本文件没有问题就不会进行热更。真正出问题的是游戏启动后，竟然使用的脚本是覆盖安装后的，而不是热更缓存的。这个问题挺头疼。 经过研究发现，覆盖安装后的ios包，并不是在原来的安装包内存上覆盖替换，而是会把旧包的内存清理掉，在新的内存上安装包。放在游戏内理解即WritablePath 发生了变化，所以我们在官方的热更方案上，将新的发现加了上去",
            "content_html": "<p>在实现cocos热更方案过程中，一切都很顺利。所有工作完成之后，发现ios 在覆盖安装之后，如果没有清理缓存，即使安装的版本是旧的也不会进行热更。这种情况，比较好理解，版本文件还在，所以比对版本文件没有问题就不会进行热更。真正出问题的是游戏启动后，竟然使用的脚本是覆盖安装后的，而不是热更缓存的。这个问题挺头疼。</p>\n<p>经过研究发现，覆盖安装后的ios包，并不是在原来的安装包内存上覆盖替换，而是会把旧包的内存清理掉，在新的内存上安装包。放在游戏内理解即<span style=\"color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);\">WritablePath 发生了变化，所以我们在官方的热更方案上，将新的发现加了上去</span></p>\n<p><code></code></p>\n<div>\n<div>let writablepath = jsb.fileUtils.getWritablePath();</div>\n<div>    var hotUpdateSearchPaths = localStorage.getItem(\"HotUpdateSearchPaths\");</div>\n<br>\n<div>    if (hotUpdateSearchPaths &amp;&amp; hotUpdateSearchPaths.indexOf(writablepath) != -1) {</div>\n<div>        var paths = JSON.parse(hotUpdateSearchPaths);</div>\n<div>        jsb.fileUtils.setSearchPaths(paths);</div>\n<div>        var fileList = [];</div>\n<div>        var storagePath = paths[0] || \"\";</div>\n<div>        var tempPath = storagePath + \"_temp/\";</div>\n<div>        var baseOffset = tempPath.length;</div>\n<br>\n<div>        if (jsb.fileUtils.isDirectoryExist(tempPath) &amp;&amp; !jsb.fileUtils.isFileExist(tempPath + \"project.manifest.temp\")) {</div>\n<div>            jsb.fileUtils.listFilesRecursively(tempPath, fileList);</div>\n<div>            fileList.forEach((srcPath) =&gt; {</div>\n<div>                var relativePath = srcPath.substr(baseOffset);</div>\n<div>                var dstPath = storagePath + relativePath;</div>\n<br>\n<div>                if (srcPath[srcPath.length] == \"/\") {</div>\n<div>                    cc.fileUtils.createDirectory(dstPath);</div>\n<div>                } else {</div>\n<div>                    if (cc.fileUtils.isFileExist(dstPath)) {</div>\n<div>                        cc.fileUtils.removeFile(dstPath);</div>\n<div>                    }</div>\n<div>                    cc.fileUtils.renameFile(srcPath, dstPath);</div>\n<div>                }</div>\n<div>            });</div>\n<div>            cc.fileUtils.removeDirectory(tempPath);</div>\n<div>        }</div>\n<div>    } else {</div>\n<div>        let path = writablepath + \"remote-hot/hall\"; //热更存放路径添加</div>\n<div>        jsb.fileUtils.addSearchPath(path, true);</div>\n<div>    }</div>\n</div>\n<p><code></code></p>",
            "author": {
                "name": "黄伟伟"
            },
            "tags": [
            ],
            "date_published": "2022-08-18T16:27:38+08:00",
            "date_modified": "2023-08-01T10:07:36+08:00"
        },
        {
            "id": "https://hweiwei.github.io/dashou/safearea-component.html",
            "url": "https://hweiwei.github.io/dashou/safearea-component.html",
            "title": "异形屏适配组件",
            "summary": "cocos creator 提供了safeArea 组件来适配刘海屏的情况，但是该组件只能在根节点生效，并且全屏适配，并不是很友好。我们仿造他实现一个轻量的子节点左右适配。实现如下： const { ccclass, property, menu, executeInEditMode, requireComponent, executionOrder } = cc._decorator; @ccclass @executeInEditMode @requireComponent(cc.Widget) @executionOrder(1000) @menu(&quot;tools/SafeArea&quot;)&hellip;",
            "content_html": "<h3 id=\"cocos-creator-提供了safearea-组件来适配刘海屏的情况，但是该组件只能在根节点生效，并且全屏适配，并不是很友好。我们仿造他实现一个轻量的子节点左右适配。实现如下：\">cocos creator 提供了safeArea 组件来适配刘海屏的情况，但是该组件只能在根节点生效，并且全屏适配，并不是很友好。我们仿造他实现一个轻量的子节点左右适配。实现如下：</h3>\n<pre><code>\nconst { ccclass, property, menu, executeInEditMode, requireComponent, executionOrder } = cc._decorator;\n@ccclass\n@executeInEditMode\n@requireComponent(cc.Widget)\n@executionOrder(1000)\n@menu(&quot;tools/SafeArea&quot;)\nexport default class SafeArea extends cc.Component {\n    @property({\n        tooltip: &quot;异形屏适配&quot;,\n        displayName: &quot;适配左边&quot;,\n    })\n    left: boolean = true;\n\n    @property({\n        tooltip: &quot;异形屏适配&quot;,\n        displayName: &quot;适配右边&quot;,\n    })\n    right: boolean = false;\n\n    onLoad() {\n        let widget = this.node.getComponent(cc.Widget);\n        if (!widget) {\n            return;\n        }\n        widget.updateAlignment();\n\n        let safeArea = cc.sys.getSafeAreaRect();\n        let viewsize = cc.winSize;\n        let widthOffset = viewsize.width - safeArea.width;\n\n        if (this.left &amp;&amp; widget.isAlignLeft) {\n            widget.left += safeArea.x;\n        }\n\n        if (this.right &amp;&amp; widget.isAlignRight) {\n            widget.right += widthOffset - safeArea.x;\n        }\n\n        widget.updateAlignment();\n    }\n\n    protected onEnable(): void {}\n}\n</code></pre>\n",
            "author": {
                "name": "黄伟伟"
            },
            "tags": [
            ],
            "date_published": "2022-08-17T15:31:56+08:00",
            "date_modified": "2022-08-18T09:16:38+08:00"
        }
    ]
}
