<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>动态规划-限定条件求最优解 - 大手游戏</title><meta name="description" content="原文发布于微信公众号https://mp.weixin.qq.com/s?__biz=MzI4MDA3MTcyMA==&amp;mid=2247483680&amp;idx=1&amp;sn=49c0d6934538cac1fe79d0430459b8d1&amp;chksm=ebbf5a67dcc8d371ca1f64da1dc7b23637cbbf1fd58e521e2cd6f4d37b4dcc79277343c81375&amp;token=1598275063&amp;lang=zh_CN#rd 游戏中经常会用到一些buff道具，最常见的比如建造建筑时使用的时间缩短道具，行军加速道具包，血量回复包等。在几种道具中选择最合适的道具包达到目标效果。许多游戏中的解决方法是使用贪心算法，这种只是一般可行解，并不被玩家接受。用动态规划算法可以构造出最优解。 动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划 我们先来构造一般意义上的最优解 假设当前我们在建造一个建筑，建筑需花费n小时的时间，玩家拥有3种道具a、b、c,分别能使建筑时间缩短1、2、3小时，我们来看看每个阶段的最优解情况 我们来解释下表格所表达的意思，一般的我们认为在所有道具都参与的情况下的解决方案为最优解，并且优先使用时效长的道具 当目标为缩短1小时的时候的最有解，结果为使用 1个道具a。同理，目标为2时使用一个b,目标为3时使用一个道具3。观察3中的第二列解 意思为当目标为缩短3个小时时，在拥有道具a和b情况下的最有解。 至此，大家应该明白表格所表达的意思了吧。 现在，我们对道具数量做出限定，假定在b、c只拥有一个的情况下，求6小时的最优解。我们继续构造最优解表格 表格理解应该是没有难度了，现在我们来分析下如何用代码实现。。。中间省略无数，直接贴代码。新建一个html打开在控制台查看结果即可。 &lt;html&gt; &lt;body&gt; &lt;script&gt; const MAX = 1000000 /**数组对象深拷贝*/&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://hweiwei.github.io/dashou/dong-tai-gui-hua-xian-ding-tiao-jian-qiu-zui-you-jie-2.html"><link rel="alternate" type="application/atom+xml" href="https://hweiwei.github.io/dashou/feed.xml"><link rel="alternate" type="application/json" href="https://hweiwei.github.io/dashou/feed.json"><meta property="og:title" content="动态规划-限定条件求最优解"><meta property="og:site_name" content="大手游戏"><meta property="og:description" content="原文发布于微信公众号https://mp.weixin.qq.com/s?__biz=MzI4MDA3MTcyMA==&amp;mid=2247483680&amp;idx=1&amp;sn=49c0d6934538cac1fe79d0430459b8d1&amp;chksm=ebbf5a67dcc8d371ca1f64da1dc7b23637cbbf1fd58e521e2cd6f4d37b4dcc79277343c81375&amp;token=1598275063&amp;lang=zh_CN#rd 游戏中经常会用到一些buff道具，最常见的比如建造建筑时使用的时间缩短道具，行军加速道具包，血量回复包等。在几种道具中选择最合适的道具包达到目标效果。许多游戏中的解决方法是使用贪心算法，这种只是一般可行解，并不被玩家接受。用动态规划算法可以构造出最优解。 动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划 我们先来构造一般意义上的最优解 假设当前我们在建造一个建筑，建筑需花费n小时的时间，玩家拥有3种道具a、b、c,分别能使建筑时间缩短1、2、3小时，我们来看看每个阶段的最优解情况 我们来解释下表格所表达的意思，一般的我们认为在所有道具都参与的情况下的解决方案为最优解，并且优先使用时效长的道具 当目标为缩短1小时的时候的最有解，结果为使用 1个道具a。同理，目标为2时使用一个b,目标为3时使用一个道具3。观察3中的第二列解 意思为当目标为缩短3个小时时，在拥有道具a和b情况下的最有解。 至此，大家应该明白表格所表达的意思了吧。 现在，我们对道具数量做出限定，假定在b、c只拥有一个的情况下，求6小时的最优解。我们继续构造最优解表格 表格理解应该是没有难度了，现在我们来分析下如何用代码实现。。。中间省略无数，直接贴代码。新建一个html打开在控制台查看结果即可。 &lt;html&gt; &lt;body&gt; &lt;script&gt; const MAX = 1000000 /**数组对象深拷贝*/&hellip;"><meta property="og:url" content="https://hweiwei.github.io/dashou/dong-tai-gui-hua-xian-ding-tiao-jian-qiu-zui-you-jie-2.html"><meta property="og:type" content="article"><link rel="stylesheet" href="https://hweiwei.github.io/dashou/assets/css/style.css?v=b5dd81eea4317d2731a94671af9140a3"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://hweiwei.github.io/dashou/dong-tai-gui-hua-xian-ding-tiao-jian-qiu-zui-you-jie-2.html"},"headline":"动态规划-限定条件求最优解","datePublished":"2023-08-01T14:46","dateModified":"2023-08-01T15:10","description":"原文发布于微信公众号https://mp.weixin.qq.com/s?__biz=MzI4MDA3MTcyMA==&amp;mid=2247483680&amp;idx=1&amp;sn=49c0d6934538cac1fe79d0430459b8d1&amp;chksm=ebbf5a67dcc8d371ca1f64da1dc7b23637cbbf1fd58e521e2cd6f4d37b4dcc79277343c81375&amp;token=1598275063&amp;lang=zh_CN#rd 游戏中经常会用到一些buff道具，最常见的比如建造建筑时使用的时间缩短道具，行军加速道具包，血量回复包等。在几种道具中选择最合适的道具包达到目标效果。许多游戏中的解决方法是使用贪心算法，这种只是一般可行解，并不被玩家接受。用动态规划算法可以构造出最优解。 动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划 我们先来构造一般意义上的最优解 假设当前我们在建造一个建筑，建筑需花费n小时的时间，玩家拥有3种道具a、b、c,分别能使建筑时间缩短1、2、3小时，我们来看看每个阶段的最优解情况 我们来解释下表格所表达的意思，一般的我们认为在所有道具都参与的情况下的解决方案为最优解，并且优先使用时效长的道具 当目标为缩短1小时的时候的最有解，结果为使用 1个道具a。同理，目标为2时使用一个b,目标为3时使用一个道具3。观察3中的第二列解 意思为当目标为缩短3个小时时，在拥有道具a和b情况下的最有解。 至此，大家应该明白表格所表达的意思了吧。 现在，我们对道具数量做出限定，假定在b、c只拥有一个的情况下，求6小时的最优解。我们继续构造最优解表格 表格理解应该是没有难度了，现在我们来分析下如何用代码实现。。。中间省略无数，直接贴代码。新建一个html打开在控制台查看结果即可。 &lt;html&gt; &lt;body&gt; &lt;script&gt; const MAX = 1000000 /**数组对象深拷贝*/&hellip;","author":{"@type":"Person","name":"黄伟伟","url":"https://hweiwei.github.io/dashou/authors/huangww/"},"publisher":{"@type":"Organization","name":"黄伟伟"}}</script></head><body><div class="site-container"><header class="top" id="js-header"><a class="logo" href="https://hweiwei.github.io/dashou/">大手游戏</a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li class="has-submenu"><span class="is-separator" aria-haspopup="true">个人作品</span><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="http://150.158.48.35:8000/gorilla/index.html" title="gorilla" target="_blank">猩猩对决</a></li><li><a href="http://150.158.48.35:8000/search/index.html" title="寻路算法" target="_blank">寻路算法</a></li><li><a href="http://150.158.48.35:8000/bezier/index.html" title="贝塞尔曲线研究" target="_blank">贝塞尔曲线研究</a></li><li><a href="http://150.158.48.35:8000/tweentyfour/index.html" title="24点" target="_blank">24点</a></li><li><a href="http://150.158.48.35:8000/sudoku/index.html" title="数独" target="_blank">数独</a></li><li><a href="http://150.158.48.35:8000/tank/index.html" title="坦克对决" target="_blank">坦克对决</a></li></ul></li></ul></nav></header><main><article class="post"><div class="hero"><header class="hero__content"><div class="wrapper"><div class="post__meta"><time datetime="2023-08-01T14:46">八月 1, 2023</time></div><h1>动态规划-限定条件求最优解</h1><div class="post__meta post__meta--author"><a href="https://hweiwei.github.io/dashou/authors/huangww/" class="feed__author">黄伟伟</a></div></div></header></div><div class="wrapper post__entry"><p>原文发布于微信公众号<a href="https://hweiwei.github.io/dashou/dong-tai-gui-hua-xian-ding-tiao-jian-qiu-zui-you-jie-2.html" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s?__biz=MzI4MDA3MTcyMA==&amp;mid=2247483680&amp;idx=1&amp;sn=49c0d6934538cac1fe79d0430459b8d1&amp;chksm=ebbf5a67dcc8d371ca1f64da1dc7b23637cbbf1fd58e521e2cd6f4d37b4dcc79277343c81375&amp;token=1598275063&amp;lang=zh_CN#rd</a></p><p>游戏中经常会用到一些buff道具，最常见的比如建造建筑时使用的时间缩短道具，行军加速道具包，血量回复包等。在几种道具中选择最合适的道具包达到目标效果。许多游戏中的解决方法是使用贪心算法，这种只是一般可行解，并不被玩家接受。用动态规划算法可以构造出最优解。</p><p>动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划</p><p>我们先来构造一般意义上的最优解</p><p>假设当前我们在建造一个建筑，建筑需花费n小时的时间，玩家拥有3种道具a、b、c,分别能使建筑时间缩短1、2、3小时，我们来看看每个阶段的最优解情况</p><table style="border-collapse: collapse; width: 115.1%; height: 325px;" border="1"><tbody><tr><td style="width: 16.3569%;">道具\目标</td><td style="width: 16.6047%;">1</td><td style="width: 16.7286%;">2</td><td style="width: 16.8524%;">3</td><td style="width: 16.6049%;">4</td><td style="width: 16.8525%;">5</td></tr><tr><td style="width: 16.3569%;">道具a（缩短1小时）</td><td style="width: 16.6047%;">a*1</td><td style="width: 16.7286%;">a*2</td><td style="width: 16.8524%;">a*3</td><td style="width: 16.6049%;">a*4</td><td style="width: 16.8525%;">a*5</td></tr><tr><td style="width: 16.3569%;">道具b（缩短2小时）</td><td style="width: 16.6047%;">a*1</td><td style="width: 16.7286%;">b * 1</td><td style="width: 16.8524%;">b * 1+ a * 1</td><td style="width: 16.6049%;">b*2</td><td style="width: 16.8525%;">b * 2 + a * 1</td></tr><tr><td style="width: 16.3569%;">道具c（缩短3小时）</td><td style="width: 16.6047%;">a*1</td><td style="width: 16.7286%;">b*1</td><td style="width: 16.8524%;">c*1</td><td style="width: 16.6049%;">c * 1 + a * 1</td><td style="width: 16.8525%;">c *1 + b * 1</td></tr></tbody></table><p>我们来解释下表格所表达的意思，<strong>一般的我们认为在所有道具都参与的情况下的解决方案为最优解</strong>，并且优先使用时效长的道具</p><p><img loading="lazy" src="https://mmbiz.qpic.cn/mmbiz_png/sXtOkUEVsctQib5DXgn1xPUibtBEibY0I63k7ic5HSX4RBhLS43icuicebfib4EtLpmCAxcjEqqm2S3ib4HHh7PNFVDY9g/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" data-is-external-image="true" alt="图片"></p><p>当目标为缩短1小时的时候的最有解，结果为使用 1个道具a。同理，目标为2时使用一个b,目标为3时使用一个道具3。观察3中的第二列解</p><p><img loading="lazy" src="https://mmbiz.qpic.cn/mmbiz_png/sXtOkUEVsctQib5DXgn1xPUibtBEibY0I63hRHPib1t9zcHKsM0IUJZiarf0ud1cCvnJTYiaQfsLWZ8SHVELh4ficSK1w/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" data-is-external-image="true" alt="图片"></p><p>意思为当目标为缩短3个小时时，在拥有道具a和b情况下的最有解。</p><p>至此，大家应该明白表格所表达的意思了吧。</p><p>现在，我们对道具数量做出限定，假定在b、c只拥有一个的情况下，求6小时的最优解。我们继续构造最优解表格</p><table style="border-collapse: collapse; width: 114.815%; height: 434px;" border="1"><tbody><tr><td style="width: 15.4762%;">道具\目标</td><td style="width: 9.04762%;">1</td><td style="width: 9.40476%;">2</td><td style="width: 11.6667%;">3</td><td style="width: 28.3333%;">4</td><td style="width: 11.9048%;">5</td><td style="width: 14.1667%;">6</td></tr><tr><td style="width: 15.4762%;">道具a（缩短1小时）</td><td style="width: 9.04762%;">a*1</td><td style="width: 9.40476%;">a*2</td><td style="width: 11.6667%;">a*3</td><td style="width: 28.3333%;">a*4</td><td style="width: 11.9048%;">a*5</td><td style="width: 14.1667%;">a*6</td></tr><tr><td style="width: 15.4762%;">道具b（缩短2小时）*1</td><td style="width: 9.04762%;">a*1</td><td style="width: 9.40476%;">b * 1</td><td style="width: 11.6667%;">b * 1+ a * 1</td><td style="width: 28.3333%;">b * 1+a * 2(原则上b*2是最优解，b数量超出,需要找出b的替代解)</td><td style="width: 11.9048%;">b * 1 + a * 3</td><td style="width: 14.1667%;">b*1 + a * 4</td></tr><tr><td style="width: 15.4762%;">道具c（缩短3小时）*1</td><td style="width: 9.04762%;">a*1</td><td style="width: 9.40476%;">b*1</td><td style="width: 11.6667%;">c*1</td><td style="width: 28.3333%;">c * 1 + a * 1</td><td style="width: 11.9048%;">c *1 + b * 1</td><td style="width: 14.1667%;">c *1 + b * 1 + a * 1</td></tr></tbody></table><p>表格理解应该是没有难度了，现在我们来分析下如何用代码实现。。。中间省略无数，直接贴代码。新建一个html打开在控制台查看结果即可。</p><p><code>&lt;html&gt;</code></p><p><code>    &lt;body&gt;</code></p><p><code>      &lt;script&gt;</code></p><p><code>          const MAX = 1000000</code></p><p><code>          /**数组对象深拷贝*/</code></p><p><code>          function copy(list) {</code></p><p><code>              let obj</code></p><p><code>            let isArr = Array.isArray(list)</code></p><p><code>              let isObj = list != null &amp;&amp; list instanceof Object</code></p><p><code>            if (isArr) {</code></p><p><code>                  obj = []</code></p><p><code>                  for (let i = 0; i &lt; list.length; i++) {</code></p><p><code>                        obj[i] = copy(list[i])</code></p><p><code>                  }</code></p><p><code>              } else if (isObj) {</code></p><p><code>                  obj = {}</code></p><p><code>                  for (let i in list) {</code></p><p><code>                      obj[i] = copy(list[i])</code></p><p><code>                  }</code></p><p><code>              } else {</code></p><p><code>                    obj = list</code></p><p><code>              }</code></p><p><code>              return obj</code></p><p><code>        }</code></p><p><code>          //删除无效项</code></p><p><code>            function removeNoCount(list) {</code></p><p><code>              let len = list.length</code></p><p><code>            while (len--) {</code></p><p><code>                  if (list[len].count == 0) {</code></p><p><code>                      list.splice(len, 1)</code></p><p><code>                    }</code></p><p><code>            }</code></p><p><code>          }</code></p><p> </p><p><code>          function getBest(list, effect) {</code></p><p><code>                let keys = copy(list)</code></p><p><code>              removeNoCount(keys)</code></p><p><code>                let kinds = keys.length</code></p><p><code>            let allEffect = 0</code></p><p><code>              for (let i of list) {</code></p><p><code>                    allEffect += i.value * i.count</code></p><p><code>            }</code></p><p><code>              //所有效果总和不比需求来得大，不必计算</code></p><p><code>              if (allEffect &lt;= effect) {</code></p><p><code>                  return { value: MAX }</code></p><p><code>              }</code></p><p><code>                let values = []</code></p><p><code>            /**构建一个二位数组表，value为当前的结果值，id为存放道具id组合*/</code></p><p><code>                for (let i = 0; i &lt;= kinds; i++) {</code></p><p><code>                  values[i] = []</code></p><p><code>                for (let j = 0; j &lt;= effect; j++) {</code></p><p><code>                      values[i][j] = {}</code></p><p><code>                      values[i][j]['value'] = MAX</code></p><p><code>                      values[i][j]['id'] = {}</code></p><p><code>                      for (let key of list) {</code></p><p><code>                          values[i][j]['id'][key.id] = 0</code></p><p><code>                      }</code></p><p><code>                    }</code></p><p><code>                  values[i][0]['value'] = 0</code></p><p><code>                }</code></p><p><code>                for (let i = 0; i &lt;= effect; i++) {</code></p><div>                    values[0][i]['value'] = MAX<p><code>              }</code></p><p><code>              for (let eff = 1; eff &lt;= effect; eff++) {</code></p><p><code>                  for (let key = 1; key &lt;= kinds; key++) {</code></p><p><code>                      //如果左侧没有最优解，则当前项不可能有最优解</code></p><p><code>                    if (values[key][eff - 1].value == MAX) {</code></p><p><code>                          values[key][eff].value = MAX</code></p><p><code>                          continue</code></p><p><code>                      }</code></p><p><code>                      let value = keys[key - 1].value</code></p><p><code>                      let id = keys[key - 1].id</code></p><p><code>                        let upItem = values[key - 1][eff]</code></p><p><code>                      let nowItem = values[key][eff]</code></p><p><code>                        //如果目标值小于当前的道具效果值，将上一个目标结果与当前的效果值做比较，取小</code></p><p><code>                        //参考 需要目标值为1时的推导</code></p><p><code>                        if (eff &lt; value) {</code></p><p><code>                          let value1 = upItem.value //目标上一个结果值</code></p><p><code>                          if (value1 &lt; value) {</code></p><p><code>                              nowItem.value = value1</code></p><p><code>                              nowItem.id = copy(upItem.id)</code></p><p><code>                            } else {</code></p><p><code>                              nowItem.value = value</code></p><p><code>                              nowItem.id[id]++</code></p><p><code>                            }</code></p><p><code>                          continue</code></p><p><code>                      }</code></p><p><code>                      let leftItem = values[key][eff - value]</code></p><p><code>                        let canUsed = leftItem.id[id] &lt; keys[key - 1].count</code></p><br><p><code>                        //当前项不可用</code></p><p><code>                      if (!canUsed) {</code></p><p><code>                          for (let k = key - 1; k &gt; 0; k--) {</code></p><p><code>                              leftItem = copy(values[k][eff - value])</code></p><p><code>                                let canUsed = leftItem.id[id] &lt; keys[key - 1].count</code></p><p><code>                                break</code></p><p><code>                          }</code></p><p><code>                      }</code></p><p><code>                      if (leftItem.value == MAX) {</code></p><p><code>                        nowItem.value = MAX</code></p><p><code>                            continue</code></p><p><code>                        }</code></p><p><code>                      let value1 = upItem.value</code></p><p><code>                      let value2 = leftItem.value + value</code></p><p><code>                      if (value1 &lt; value2) {</code></p><p><code>                          nowItem.value = value1</code></p><p><code>                          nowItem.id = copy(upItem.id)</code></p><p><code>                      } else {</code></p><p><code>                          nowItem.value = value2</code></p><p><code>                          nowItem.id = copy(leftItem.id)</code></p><p><code>                          nowItem.id[id]++</code></p><p><code>                      }</code></p><p><code>                    }</code></p><p><code>              }</code></p><p><code>              console.log(values[kinds][effect])</code></p><p><code>                return values[kinds][effect]</code></p><p><code>          }</code></p><p><code>          let list = [</code></p><p><code>              { id: '时间道具a', value: 3, count: 6 },</code></p><p><code>                { id: '时间道具b', value: 5, count: 2 },</code></p><p><code>            { id: '时间道具c', value: 7, count: 2 },</code></p><p><code>              { id: '时间道具d', value: 99, count: 5 },</code></p><p><code>            ]</code></p><p><code>        let eff = 517</code></p><p><code>            getBest(list, eff)</code></p><p><code>      &lt;/script&gt;</code></p><p><code>    &lt;/body&gt;</code></p><p><code>&lt;/html&gt;</code></p><p><code></code></p></div></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on 八月 1, 2023</p><div class="post__share"></div><div class="post__bio bio"><div class="bio__info"><h3 class="bio__name"><a href="https://hweiwei.github.io/dashou/authors/huangww/" rel="author">黄伟伟</a></h3></div></div></footer></article><nav class="post__nav"><div class="post__nav-inner"><div class="post__nav-prev"><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://hweiwei.github.io/dashou/assets/svg/svg-map.svg#arrow-prev"/></svg> <a href="https://hweiwei.github.io/dashou/cocosre-geng-dong-tai-ban-ben-di-zhi-yan-jiu-2.html" class="post__nav-link" rel="prev"><span>Previous</span> cocos热更动态版本地址研究</a></div></div></nav></main><footer class="footer"><div class="footer__copyright"><p>dashou</p></div><button onclick="backToTopFunction()" id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg><use xlink:href="https://hweiwei.github.io/dashou/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script defer="defer" src="https://hweiwei.github.io/dashou/assets/js/scripts.min.js?v=f47c11534595205f20935f0db2a62a85"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');

        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>